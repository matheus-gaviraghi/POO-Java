Exercicio 4.4:
- O construtor de uma classe deve ser público para ter acesso à própria classe
- para a classe Data ser visível externamente, deveria colocar o public class


Exercicio 4.5:
- Linha 6: o construtor deveria ser chamado com um this


Exercicio 4.6:
int soma (int x, int y) vs float soma (int x, int y) 
- Isso aqui não funciona, pois não é possível diferenciar os metodos
- Se for assim funciona: int soma (int x, int y) vs float soma (float x, int y)

Por ter os mesmos parametros, esse codigo do exercicio nao é compilado


Exercicio 4.7:
Linha 7:  tenho que colocar o this
- O construtor a gente sempre chama após chamar o metodo, entao a linha 7 deveria vir antes da 8


Exercicio 4.8:
- 2 metodos com mesma assinatura (mesmos parametros)
- Por definicao construtor nao retorna nada, só executa as operações, entao os returns estao errados


Exercicio 4.17:



Exercicio 4.18:
1 metodo A
2 metodo A
3 metodo A
4 metodo A
5 metodo B


========== CAMPOS E MÉTODOS ESTÁTICOS =========
- Tenho 1 metodo que quero compartilhar pra toda classe, e não individual para cada objeto
- Vale para todos os objetos
- Ex: so tenho 1 main

- Mesma ideia de uma variavel global em C: quero que todos possam acessar
- o static é o que permite o compartilhamento de informações entre os objetos
- Todos vao enxergar o mesmo numero sempre (Ex: SimuladorCaixaDeBanco2)
- Coloco static entre o modificador de acesso e o tipo da variavel

Constantes de classe: 
    static: unico, todos tem acesso, modificavel
    final: constante, nao modificavel

- Exemplo DemoConstantesMatematicas: 
    Linha 13 (a que tenho apenas a classe sendo chamada, sem um objeto em si -> c1.raizDe5 == ConstantesMatematicas.raizDe5): por ser unico, posso usar a classe dentro de outro codigo sem precisar instanciar a classe

Métodos Estáticos:
- quero ter um metodo unico para todos os meus objetos
- todos os atributos internos desse metodo devem ser estaticos
- Exemplo CalculoDePrecoDeTerreno: double preco é estatico e unico
- tudo que for criado dentro de um contexto estatico se torna estatico
- se quiser chamar um metodo que nao é estatico dentro de uma mesma classe onde o metodo que requer é estatio, nao funciona. Ex: se eu tirar o static do metodo precoDoTerreno, na main vai dar problema
- agora se eu tiver uma outra classe que realize este calculo, e lá nao foi definido como estatico, mas eu chamo na main essa classe, automaticamente o metodo e atributos vao se tornar estaticos, e vai funcionar direitinho

SOMENTE MÉTODOS E ATRIBUTOS PODEMOS DECLARAR COMO ESTÁTICOS
- O construtor não pode ser estatico, visto que este é executado ao chamar a classe
- O construtor não faz sentido quando tenho todos atributos e metodos estaticos, uma vez que não preciso instaciar um novo objeto.

- O que muda um metodo (assinatura) é o seu nome e seus parametros (tipo e quantidade), não o tipo do return (Exercicio 5.12)


AULA 07/10
Construtores - NAO RETORNAM, o proprio sistema constroi o retorno, a gente nao deve tentar
especificar um retorno

Dentro de um mesmo escopo, se tiver 2 variaveis com mesmo nome, tenho que usar o this para referenciar ao atributo do objeto.
    Data(int mes, int dia, int ano){
        this.mes = mes;
        this.dia = dia;
        this.ano = ano;
    }

Reutilização de Código:
- Add informação em classes ja existentes (atributos e métodos) para reutilizar essas classes.
- 2 formas de reutilização: delegação (ou composição) e herança.
    Delegação: utilizo objetos com base em classes que ja foram criadas (crio objetos) - o que estavamos fazendo até agora
        - Na delegação, inicializo no construtor os objetos que sao reutilizados
        - Os modificadores de acesso são mantidos (as regras de acesso são mantidas)
        Slide ?OU?: nao conseguimos modificar o valor de k em nenhuma das opções, pois x1 é privado, teria de ser *publico* ou protegido
        OBS: o protegido funciona como se fosse publico dentro de um mesmo diretorio, mas nao deixa que outros diretorios acessem
    Herança: herdar informações e add novas informações as classes
        - palavra-chave: extends
        Ex: class PacienteDeClinica extends Pessoa{...} -> Paciente tem as caracteristicas de Pessoa
        - se tiver private no pai, não adianta tentar acessar no filho, não consegue! Tem que ser protegido.
        - SÓ 1 PAI, para ter mais temos que usar Interface (herança multipla)
        - Ocultação: redeclaração de um campo/atributo do pai no filho
        - super: aponta pro objeto pai
        - this: aponta pro proprio objeto
        SEMPRE: primeiro cria objeto pai e depois trabalha com atributos
        - super. : especifico o atributo ou metodo do pai que quero trabalhar
        - super.super: NÃO DÁ